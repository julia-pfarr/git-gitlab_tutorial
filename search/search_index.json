{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tutorial Objectives","text":"<p>This tutorial is made for researchers in psychology or neurosciences with little to no background in software development or no other computational expertise.</p>"},{"location":"#topics","title":"Topics \ud83d\udca1","text":"<p>Please try to reserve 3-4h of your time for this tutorial. If you plan on rushing through this tutorial, you will only get frustrated. I know that 3-4h seem like a lot of time, but after this tutorial you will be prepared for working collaboratively with Git and GitLab. This tutorial is created in a praxis-oriented manner and under every section you'll find tasks which are nice for getting some practice. Because: You can only learn Git and GitLab by actually doing it!!</p> <p>This tutorial teaches to work with Git through the command line. This has the purpose to make you understand what's really going on when you communicate with Git. However, you are welcome to use one of the many Graphical User Interfaces (Git GUIs) for Git which are more user friendly than working with the command line. </p> <p>Please be reminded that for going through this tutorial you need to have gone through the Installation and Setup part.</p>"},{"location":"#version-control-and-git-background-and-theory","title":"Version Control and Git: Background and Theory","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>What Version Control is and where it comes from</li> <li>Why it is useful</li> <li>The basic principles of Git:<ul> <li>the Git database</li> <li>structure of the Git repository</li> <li>the staging area</li> <li>commits</li> </ul> </li> </ul>"},{"location":"#basic-git-workflow","title":"Basic Git Workflow","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>init</li> <li>add</li> <li>commit</li> <li>status</li> <li>diff</li> <li>log</li> </ul>"},{"location":"#branching-and-merging","title":"Branching and merging","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>branch</li> <li>checkout</li> <li>merge</li> <li>HEAD and detached HEAD</li> <li>moving in your commit history</li> <li>how to solve a merge conflict</li> </ul>"},{"location":"#gitlab-workflow","title":"GitLab workflow","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>What is GitLab</li> <li>local vs. remote repository</li> <li>push</li> <li>pull</li> <li>clone</li> <li>fetch</li> <li>merge</li> <li>merge conflict between your local and remote repository</li> </ul>"},{"location":"#contributing-on-gitlab","title":"Contributing on GitLab","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>fork</li> <li>merge requests</li> <li>gitlab for project management</li> <li>git LFS</li> </ul>"},{"location":"#optionalreadingfurther-materials","title":"optional/reading/further materials","text":"<ul> <li>YouTube is full of Git/GitLab/GitHub videos for all kinds of levels and features!!! For example: Brainhack Git introduction or GitHub CI</li> <li>Git cheat sheet by gitlab or github</li> <li>Atlassian tutorials and cheat sheet</li> <li>Troubleshooting: Oh shit git or Dangit git (are the same, but the latter is without swearing)</li> <li>Git branching</li> <li>Git GUIs </li> <li>Advanced Git commands</li> <li>NOWA workshops</li> <li>really, just type anything you want to know about Git in YouTube and you'll find a tutorial for it. </li> </ul>"},{"location":"basics/","title":"Basic local Git Workflow","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>init</li> <li>add</li> <li>commit</li> <li>status</li> <li>diff</li> <li>log</li> </ul> <p>Note: For this tutorial you will need a project folder to work on. </p> <p>Now that we have a basic understanding of what Git is and what it does, we want to try it. In this section we want to make changes to our project and therefore create different versions of our project. To do so, we first need to learn the basic vocabulary of Git. </p> <p>Git vocabulary</p> <ul> <li><code>git init</code>: to give git initial control over your files</li> <li><code>git add</code>: adds a change from the working directory into the staging area</li> <li><code>git commit</code>: saves a snapshot of the current version of your project in the repository</li> <li><code>git status</code>: check the status of the files</li> <li><code>git diff</code>: let\u2019s you inspect differences between versions (in a certain way)</li> <li><code>git log</code>: to view the commit history</li> </ul>"},{"location":"basics/#first-steps","title":"First steps","text":"<p>The very first step at the beginning of version controlling your files is to tell git to draw attention to this folder. With <code>git init</code> we give git the power to track our files. </p> <p>Navigate to your project folder in your command line/ terminal. You can also use VSCode as an IDE to work on your project. There you have an integrated terminal and are always in the folder which you currently have open in VSCode.</p> <p>When you are in the right directory, type:</p> <pre><code>git init \n</code></pre> <p>git init</p> <p>However, our files are not tracked yet, for this we have to add and commit the files with a first commit. We can check this by typing </p> <pre><code>git status\n</code></pre> <p>git status</p> <p>Through the power we gave git by doing a <code>git init</code>, git always knows exactly what's going on in our folder. <code>git status</code> will tell us what that is. When using git only locally, we can have three different outputs of <code>git status</code>:</p> <ul> <li>untracked files: git knows there are files in our folder but we didn't tell git to actually track them. Either we created a new file and haven' added it yet or we simply don't want this file to be tracked. </li> <li>changes not staged for commit: at some point we added this file and git tracks its status. Now we made changes to this file but we haven't added them, yet.</li> <li>changes to be committed: these changes we already added to the staging area and will be included in our next commit. </li> </ul> <p>Let's move on. Because we want EVERYTHING in our folder be tracked by git, we simply add and commit everything at once. First we type</p> <pre><code>git add .\n</code></pre> <p>git add</p> <p>Like we learned in the previous section, <code>git add</code> allows us to add files individually to the staging area. With the <code>git add .</code> we added ALL files to the staging area (that's what the <code>.</code> does after add). If you want to stage your files individually, you simply exchange the <code>.</code> with the name of the file you want to stage.</p> <p>Now that we have all our files staged and waiting for the train to version database, we can commit them. We type</p> <pre><code>git commit\n</code></pre> <p>and our text editor opens automatically. This is because with every commit we need to write a commit message to know later what this commit was about. </p> The nano and vim text editors <p>In case you configured nano or vim as your default text editor when using git (vim is the default editor on MaRC3a/JupyterHub): Those text editors are command-line editors which means they open directly in the terminal (no new window opens). With everything, you just need to know how to operate it:</p> <p>nano: - when the editor opens for the commit message, you need to first press <code>enter</code> one time to make new line at the top.  - when you've done writing your commit message, you need to save and close it: <code>CTRL X</code> closes it but it asks you first if you want to save it by typing a capital <code>Y</code>, then <code>Enter</code>.</p> <p>vim: - when the editor opens you first need to type <code>i</code> to change from command mode to insert mode - make a new line at the top by pressing <code>Enter</code> - write your commit message and then press <code>Esc</code> and then <code>:wq</code> to save and exit</p> <p>Commit message structure</p> <p>When the text editor opens and asks us for a commit message we have to insert a title and the actual commit message. The first line we write will be the title. The title should be short and expressive. Then we make an empty line and after this we write a longer commit message. This message can be as long as you wish or need it to be.</p> <p>Because this is our first commit we can simply write a commit message like </p> <p>\"initial commit\"</p> <p>\"added all my files of the choice_rtt project to be tracked by git\"</p> <p>Later, we need to be more specific when describing what we changed.</p> <p>NOTE FOR MAC USERS: Please make sure your text editor really saves files in <code>.txt</code> and not <code>.rtf</code>. </p> <p>Please make sure that your text editor is really closed!!!</p>"},{"location":"basics/#making-changes","title":"Making changes","text":"<p>Now we want to explore a bit the different functions of git. For this we need to make our first change. Open one of your files and make a change. Afterwards, type <code>git status</code> again. What does it say now?</p> <p>So, we need to stage our change before we can commit it. We type </p> <pre><code>git add *path-to-your-file*\n</code></pre> <p>because we only want this file to be committed. Why? Because a commit message is bound to the changes we commit and we want to write a useful commit message that says what we changed. We will see later why this is important. Now, commit your change and give it a useful commit message. </p> <pre><code>git commit \n</code></pre> <p>git commit</p> <p>When you do a git commit, you don't need to specify which file you are committing as every file in the staging area will be committed. If you don't want certain files to be committed together, you need to specify this by your add-commit workflow. Every time you do a <code>git add</code>, a file comes into the staging area and is included in the next commit. </p> <p>Example:</p> <p>You made changes on file1, file2, and file3. An add-commit workflow like this <code>git add file1</code> <code>git add file2</code> <code>git commit</code> <code>git add file3</code> <code>git commit</code> leads to file1 and file2 committed together, file3 separately.</p> <p>Whereas an add-commit workflow like this <code>git add file1</code> <code>git add file2</code> <code>git add file3</code> <code>git commit</code> leads to all three files being committed together.</p> <p>Again, our text editor opens and asks us for our commit message, so we should do that. </p> <p>When we do a <code>git status</code> again now, it should tells us </p> <p>\"nothing to commit, working tree clean\"</p> <p>which basically means that the version in our working directory is the exact same version as the last committed version (remember the structure of the git repository from the previous section). </p> <p>Task 1</p> <p>1) Make a change to one of your files. Add and commit it like we just did.</p> <p>2) Make another change. Don't add it. </p> <p>3) Create a new file and write something in it.</p> <p>4) Do a <code>git status</code>. What does it say? Do what it says needs to be done to get a clean working tree. Try the tip \"git commit -m\" below for committing. </p> git commit -m <p>If you type <code>git commit -m</code> instead of <code>git commit</code>, git expects you to write a very short commit message after the <code>m</code>, like <code>git commit -m \"my commit message\"</code>. This short commit message basically replaces the title+message form and the commit message should be short and precise. You do not have more information to this commit than the short commit message. You should always think about when to make a short commit message and when you might need a longer explanation on what you've changed.  </p>"},{"location":"basics/#looking-at-differences","title":"Looking at differences","text":"<p>Another great thing of git, besides storing different versions for us, is its ability to show us exactly what we changed. For this we have an extra command called <code>git diff</code>. Let`s try this.</p> <p>Make another change to your file, close it, but DON'T commit it for now. We can now look at the difference between the version in our working directory and the one in our version database (= last committed version). Let's type a <code>git diff</code>. The output looks weird but is actually really helpful, here's an example of a git diff with an explanation below<sup>1</sup>:</p> <pre><code>diff --git a/diff_test.txt b/diff_test.txt\nindex 6b0c6cf..b37e70a 100644\n--- a/diff_test.txt\n+++ b/diff_test.txt\n@@ -1 +1 @@\n-this is a git diff test example\n+this is a diff example\n</code></pre> <ul> <li>the first line just tells us which file is being compared. If you included multiple files in your commit, the differences for each file will be shown individually. So after all the differences for one file, the differences shown for another file start with this line <code>diff --git name-of-the-file</code> again.</li> <li><code>index</code> shows us the hashes of the files being compared. You're right, we didn't commit our current version so it shouldn't have commit hash, yet. Well, git assigns a hash to it anyway but it's not really a commit hash but you can think of it more like a \"working directory hash\". </li> <li>the third number after <code>index</code> tells us which kind of file it is. <code>100644</code> for example stands for an ordinary text file. </li> <li><code>--- a/filename</code> and <code>+++ b/filename</code>: changes from <code>a/diff_test.txt</code> are marked with a <code>---</code> and the changes from <code>b/diff_test.txt</code> are marked with the <code>+++</code> symbol</li> <li>The remaining diff output is a list of diff 'chunks'. A diff only displays the sections of the file that have changes. In our current example, we only have one chunk as we are working with a simple scenario. Chunks have their own granular output semantics</li> <li>The first line is the chunk header. Each chunk is prepended by a header enclosed within <code>@@</code> symbols. The content of the header is a summary of changes made to the file. In our simplified example, we have -1 +1 meaning line one had changes </li> <li>In a more realistic diff, you would see a header like <code>@@ -34,6 +34,8 @@</code>: In this header example, 6 lines have been extracted starting from line number 34. Additionally, 8 lines have been added starting at line number 34</li> <li>The remaining content of the diff chunk displays the recent changes. Each changed line is prepended with a + or - symbol indicating which version of the diff input the changes come from</li> </ul> <p>git diff</p> <p>By simply typing <code>git diff</code> you will be shown the difference between the current version in the working directory and the last committed version. However, we can also look at differences between two committed versions or the difference to a staged version. For this we need the assigned commit hashes, which we can find out through a <code>git log</code>.</p>"},{"location":"basics/#the-commit-history","title":"The commit history","text":"<p><code>git log</code> will show you your commit history. Your commit history is basically a list of all your commits annotated with metadata. One of the <code>git log</code> metadata are the commit hashes which you will need to search for/ go back to older versions or creating new branches (which we will learn in a sec). To see your commit history, simply type <code>git log</code>. Here's an example and explanation of what we see:</p> <pre><code>commit 211a87947765cb34fe922bb39eed8e2357ea5ae9 (HEAD -&gt; main)\nAuthor: julia-pfarr &lt;pfarr@staff.uni-marburg.de&gt;\nDate:   Thu Feb 8 18:57:23 2024 +0100\n\n    change Git intro\n</code></pre> <ul> <li>The first line is the commit hash. That's a unique identifier for this commit</li> <li>The next two lines are author and date. If you start working collaboratively on a project, you will also see entries from your collaborators</li> <li>the next line is the title you gave your commit. If you put in a longer commit message, you would also see this longer commit message.</li> <li><code>(HEAD -&gt; main)</code>: <code>HEAD</code> is a symbolic reference pointing to wherever you are in your commit history. When you move in your commit history, <code>HEAD</code> moves with you, like a shadow. In our example, <code>HEAD</code> is with the latest commit and is pointing to <code>main</code>. This means we are on the latest commit that was made on the branch <code>main</code>. We will learn in the next section why having the <code>HEAD</code> reference is very useful. </li> </ul> <p>git log</p> <ul> <li>to exit <code>git log</code>, press <code>q</code></li> <li> <p>to only show a concentrated version of the commit history, type <code>git log --oneline</code>. It will only have the last 7 digits of the commit hash (which is all you need), the title of the commit, and the <code>HEAD</code> and <code>main</code>info, like this:</p> <pre><code>211a879 (HEAD -&gt; main) change Git intro\nc3c16d6 finish intro\ne4a1e75 add online experiment section to psychopy\n8644c34 add graphics to PsychoPy dir for testing\n7506aa6 delete Remote WSL extension\n541c70c reset\n0ec1af7 fix image path in psychopy intro\n</code></pre> </li> </ul> <p>Task 2</p> <p>Do a <code>git diff</code> between your second commit and your second to last commit.</p> Answer <ul> <li><code>git log --oneline</code> to find the commit hashes assigned to the respective commits</li> <li><code>git diff HASH_OLDER_COMMIT HASH_NEWER_COMMIT</code></li> </ul> <p>Here`s an overview on what we did so far<sup>2</sup>:</p> <p></p>"},{"location":"basics/#git-and-binary-files","title":"Git and binary files","text":"<p>Git is not good at handling binary files. You can still track them using git by adding and comitting them but git can't do a <code>git diff</code> of binary files. The reason is that git actually reads the files, thus it needs file formats that are text based (like usual code file types such as .py, .m, .R, or text files like .txt, .md, or tables in .csv, .tsv). File types like .docx, .xlsx, .pdf or images like .png, jpeg and so on are binary files which means the content of the files is actually stored in 0s and 1s. Therefore, <code>git diff</code> is not really working. There are some options how you can still diff binary files with git (see this entry \"diffing binary files\") but it is just easier not to. </p> <p>If you have a lot of binary files and large files in your project you might want to think about excluding those files from the diff operations of git and also checking them into Git LFS instead. Because git checks all files every time and needs to come to the conclusion every time that this particular files is binary. Sometimes this can go wrong and git could possibly destroy your binary file. To avoid this you can create a <code>.gitattributes</code> files (the <code>.</code> before the file name is important!!) and tell git to track those files with Git LFS instead. </p> <p>Task 3</p> <p>Create a <code>.gitattributes</code> files on the first level in your project folder:</p> <p>1) make new file <code>.gitattributes</code>. 2) put the following content:</p> <pre><code>    ```\n    # Source files\n    # ============\n    *.pxd    text diff=python\n    *.py     text diff=python\n    *.py3    text diff=python\n    *.pyw    text diff=python\n    *.pyx    text diff=python\n    *.pyz    text diff=python\n    *.pyi    text diff=python\n\n    # Binary files\n    # ============\n    *.db     binary\n    *.p      binary\n    *.pkl    binary\n    *.pickle binary\n    *.pyc    binary export-ignore\n    *.pyo    binary export-ignore\n    *.pyd    binary\n\n    # Jupyter notebook\n    *.ipynb  text eol=lf\n\n    # Graphics: when git-lfs activated, exchange 'binary' with: filter=lfs diff=lfs merge=lfs -text\n    *.png      binary \n    *.jpg      binary\n    *.jpeg     binary\n    *.gif      binary\n    *.tif      binary\n    *.tiff     binary\n    *.ico      binary\n    # SVG treated as text by default.\n    *.svg      text\n    # If you want to treat it as binary,\n    # use the following line instead.\n    # *.svg    binary\n    *.eps      binary\n\n    # Documents\n    *.bibtex   text diff=bibtex\n    *.doc      binary\n    *.DOC      binary\n    *.docx     binary\n    *.DOCX     binary\n    *.dot      binary\n    *.DOT      binary\n    *.pdf      binary\n    *.PDF      binary\n    *.rtf      diff=astextplain\n    *.RTF      diff=astextplain\n    *.md       text diff=markdown\n    *.mdx      text diff=markdown\n    *.tex      text diff=tex\n    *.adoc     text\n    *.textile  text\n    *.mustache text\n    *.csv      text eol=crlf\n    *.tab      text\n    *.tsv      text\n    *.txt      text\n    *.sql      text\n    *.epub     diff=astextplain\n</code></pre> <p>.gitignore</p> <p>Another config file of git is <code>.gitignore</code>. In this file you can state if you want certain files or whole directories excluded from being tracked by git. Sure, you could also just not add them. But then you will always get the message of untracked files and that might annoy or confuse you with time. So, instead you can just list those files or directories in a <code>.gitignore</code> file. </p> <p>For example, Mac Users should set the <code>.DS_Store</code> files to be ignored. You can either do that globally (<code>echo .DS_Store &gt;&gt; ~/.gitignore_global</code>, then <code>git config --global core.excludesfile ~/.gitignore_global</code>), or in a <code>.gitignore</code> file. The <code>.gitignore</code> file has the same structure as the <code>.gitattributes</code> file. Templates can be found here.</p> <ol> <li> <p>Example and description retrieved from Atlassian Git Tutorial \u21a9</p> </li> <li> <p>Image by Peer Herholz\u00a0\u21a9</p> </li> </ol>"},{"location":"branching_merging/","title":"Branching and Merging","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>branch</li> <li>checkout</li> <li>merge</li> <li>HEAD and detached HEAD</li> <li>moving in your commit history</li> <li>how to solve a merge conflict</li> </ul> <p>Now that we know how to make,record, and inspect changes with git we want to dive into the really cool features of git. In the introduction we heard something about \"multiple streams of work\". In git this is done by <code>branches</code>. So far we only worked on the <code>main</code> branch. This is our main development stream. However, sometimes we want to try something new with our code and see if it works out without trashing our main development stream with too many commits. Or, we work collaboratively and you work on one module of the code and your collaborator works on another module of the code. To not interfere too much and having to incorporate the changes of your collaborator all the time and keep a clean main development stream, you should work on separate branches. In the end, you can <code>merge</code> your versions into the main branch. </p> Branching with git. You always start your development on the main branch. Along the way you might want to try out different things while keeping your main development stream clean. For this you can create as many branches as you need, working on them in parallel and incorporate the work you did on these features into the main branch. Or not. <p>Before we try this, we need some more vocabulary:</p> <p>More Git vocabulary</p> <ul> <li><code>git branch</code>: create a new branch</li> <li><code>git checkout</code>: check out (or \u201creplace\u201d) file in working directory with another staged or committed version AND move between branches</li> <li><code>git merge</code>: to merge two separate sets of version (branches) into one</li> </ul>"},{"location":"branching_merging/#creating-a-new-branch","title":"Creating a new branch","text":"<p>Let's say you were asked by our supervisor to set up your experiment with a new feature, e.g., adding some eye tracking in addtion to your EEG experiment. Because want to keep the main development stream clean and we know that we need to work on the eye tracking feature a lot, we decide to set up an extra branch for it. </p> <p>Task 4</p> <p>1) Create a new branch by typing <code>git branch eyetrack</code>. Check with <code>git branch</code> if it worked.  2) Switch to your new <code>eyetrack</code> branch by typing <code>git checkout eyetrack</code>. You should see \"Switched to branch eyetrack\". Check if you are really on the new branch.  3) Make a change to your experiment code, add and commit it.  4) Do a <code>git log</code>. </p> <p>What is different about the git log output compared to the last git log we did? </p> <p>Why is <code>HEAD</code> not with <code>main</code>?</p> <p>git branch</p> <ul> <li>to know which branch we're currently on we can do a <code>git branch</code></li> <li>we can switch between branches by doing <code>git checkout branchname</code></li> <li>instead of <code>git branch name-of-new-branch</code> plus <code>git checkout name-of-new-branch</code> we could also just do a <code>git checkout -b name-of-new-branch</code></li> </ul>"},{"location":"branching_merging/#moving-around-in-your-commit-history","title":"Moving around in your commit history","text":"<p><code>git checkout</code> is not only for moving between branches, but also to move on one branch between commits. You might want to do this because you realize that you like the instructions for your experiment from a previous version much better and want to bring them back without loosing all the other changes you did on the way. Or, you might want to create a branch not from the last commit but from a way earlier commit.</p> <p>git checkout</p> <ul> <li><code>git checkout</code> allows you to move around in your commit history and between branches</li> <li><code>git checkout HASH</code> leads you to an earlier version of your project on your current branch</li> <li><code>git ceckout branchname</code> leads you to the latest commit made on the branch you've chosen to go to. Every commit you make now will be recorded on the branch you checked out to. To record changes to another branch, you first have to do a <code>git checkout other-branchname</code> again</li> <li>checking out to an earlier commit brings you in the so-called detached HEAD stage. This means that you are currently not connected to any branch. To make changes on the version you're currently on, you first need to create a new branch, then make the changes. When you made your changes, you can merge the new branch with your <code>main</code> branch to incorporate the changes to main </li> </ul> <p>Task 5</p> <p>1) Create a new branch from the <code>eyetrack</code> branch make a commit on the new branch. 2) Switch to the <code>main</code> branch and make a commit.  3) Move to your third commit. Create a branch from this commit.  4) Switch back to the <code>main</code> branch</p> Answer <p>1) check with <code>git branch</code> if you're currently on the <code>eyetrack</code> branch. If not: <code>git checkout eyetrack</code>. Make a change. <code>git add change</code> &amp; <code>git commit</code>. 2) <code>git checkout main</code>. Make a change. <code>git add change</code> &amp; <code>git commit</code> 3) <code>git log</code> to find hash of third commit. <code>git checkout hash-of-third-commit</code>. <code>git branch new-branch</code> 4) <code>git checkout main</code></p> <p>Task 6</p> <p>How does our development stream look like? Draw your commit history with all the branches like in Fig. 13 shown at the top of this page. </p>"},{"location":"branching_merging/#merging-and-merge-conflicts","title":"Merging and merge conflicts","text":"<p>Merging means bringing two independent development streams together. Previously, we said we wanted to add an eye tracking feature to our experiment code. Now that we worked on it a bit we are certain that we can incorporate eye tracking into our experiment. This means, we want to incorporate our work from the <code>eyetrack</code> branch into the <code>main</code> branch. It will look like this <sup>1</sup>: </p> Independent branches of work. Merged branches. <p>git merge</p> <ul> <li>Merging always refers to two branches</li> <li>with the command <code>git merge name-of-the-branch</code>, <code>name-of-the-branch</code> will be incorporated into the branch you're currently on</li> <li>especially when you start working collaboratively with git, you will run into <code>merge conflicts</code>. This is something common and not a catastrophe. There is a solution to the conflict (see below).</li> </ul> <p>Task 7</p> <p>Merge the <code>eyetrack</code> branch into the <code>main</code> branch. </p> Answer <ul> <li>check if you're currently on the <code>main</code> branch. If not: <code>git checkout main</code></li> <li><code>git merge eyetrack</code></li> </ul> <p>Did you run into a merge conflict? If not, do the optional Task.</p> Optional task to induce a merge conflict <p>1) <code>git checkout eyetrack</code> 2) change something in your code on the eyetrack branch by deleting something in your instructions and writing an alternative text on the exact same place as you deleted from. Add and commit.  3) <code>git ceckout main</code>  4) <code>git merge eyetrack</code></p> <p>The reason why we run into merge conflicts is because of the way git tracks the changes in our files. Git inspects our project on a file-by-file and line-by-line basis. This is the reason why a <code>git diff</code> can give us such detailed information about our changes. However, this also means that when we make changes on the <code>eyetrack</code> branch to a line that already exists on the <code>main</code> branch and then want to merge, git simply is confused and doesn't know which one of the two versions we want to keep. </p> <p></p> <p>So, git is super nice and asks us which one we want to keep by giving us a notice about a merge conflict. A merge conflict looks like this: </p> <pre><code>git merge eyetrack\nAuto-merging crtt_exp.py\nCONFLICT (content): Merge conflict in crtt_exp.py\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre> <p>As you can see, git tells us in which file the merge conflict appeared and asks us to fix the conflicts. We can fix it by opening the file and modifying it so that only one version stays. </p> <p>Task 8</p> <ul> <li>open the file in which the merge conflict appeared </li> <li>at the place where the merge conflict is you will see this:</li> </ul> <p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD this is the content of the file on <code>main</code> ... ======= this is the content of the file on <code>eyetrack</code> . &gt;&gt;&gt;&gt;&gt;&gt;&gt; eyetrack</p> <p>You can see that git tells you where the merge conflict starts and what the merge conflict is about. Thanks to VSCode you have some buttons where you can click on to choose which of the two versions you want to keep.</p> <ul> <li>solve the merge conflict</li> <li>add and commit the file</li> <li>do a <code>git merge</code> again</li> <li>Check with the Git-Graph feature of VSCode how your project development looks like</li> </ul> <p>Now that we are experts in using git locally on our machine, we're finally ready to start using git collaboratively!!!!</p> <p><p><p>via GIPHY</p></p></p> <p>P.S.: check out this tutorial for learning advanced git commands. </p> <ol> <li> <p>Figures retrieved from the Atlassian tutorial \u21a9</p> </li> </ol>"},{"location":"contribute/","title":"Contributing and Collaboration on GitLab","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>fork</li> <li>merge requests</li> <li>gitlab for project management</li> </ul>"},{"location":"contribute/#forking-and-merge-requests","title":"Forking and merge requests","text":"<p>Sometimes you want to contribute to a project on gitlab but you don't have write access. This is usually the case if you are not added as a member to the project. Even if the project is public, you cannot contribute to it without opening a <code>merge request</code>. The same is true for your own repos: you can make them public, people can <code>clone</code> them but they cannot change something on the project without asking you first through a <code>merge request</code>. </p> <p>Like mentioned before, even if you are a member of the project and work together with your collaborators, it is always a good idea to work with <code>merge requests</code> to foster communication and avoid a ton of conflicts. We highly advise you to ALWAYS work with branches and merge requests!</p> <p>To open a <code>merge request</code> on a repo where you don't have write access to, you first need to <code>fork</code> this project. You'll find the <code>fork</code> button on the upper right in the respective gitlab repo. Forking a project means copying a remote repository from another user as a remote repository under your username. </p> <p>Task 14</p> <ul> <li>Go to this repo on GitLab</li> <li>fork the project</li> <li>clone your forked project</li> <li>make a change and push it back to your forked project </li> <li>open a <code>merge request</code> on the original project:<ul> <li>go to the original repo</li> <li>click on <code>merge requests</code> on the left sidebar</li> <li>select your repo and branch as <code>source branch</code> and as <code>target branch</code> select the original repo and branch </li> </ul> </li> <li>on the original repo you should see a new merge request. Now the owner of the original repo can review it and decide to approve and merge it, or not. </li> </ul> <p>This is how your collaborative workflow on GitLab should look like, even if every collaborator has access. </p> <p> </p>"},{"location":"contribute/#gitlab-for-project-managing","title":"GitLab for project managing","text":"<p>GitLab is actually more than just a code development platform. It has so many additional functions. Under the section <code>Plan</code> you can manage tasks (<code>issues</code> and <code>issue board</code>), keep track of important <code>milestones</code> and assign <code>issues</code> to <code>milestones</code>. You can write a comprehensive <code>wiki</code> to store important information about the project (e.g., links to other important resources such as data repo, document meeting minutes etc.). </p> <p>You can also do automated testing of your code (<code>continuous integration</code>/<code>CI</code>), build packages or container for apps and <code>deploy</code> them to e.g., docker. </p> <p>It allows you to do a bunch of other stuff which is related to project analytics which is mostly used in industry and exceeds the goals of a science project in academia.</p>"},{"location":"contribute/#extra-git-lfs","title":"Extra: Git LFS","text":"<p>Note: Text and images retrieved from atlassian.com</p> <p>Git is a distributed version control system, meaning the entire history of the repository is transferred to the client during the cloning process. For projects containing large files, particularly large files that are modified regularly, this initial clone can take a huge amount of time, as every version of every file has to be downloaded by the client. Git LFS (Large File Storage) is a Git extension developed by Atlassian, GitHub, and a few other open source contributors, that reduces the impact of large files in your repository by downloading the relevant versions of them lazily. Specifically, large files are downloaded during the checkout process rather than during cloning or fetching.</p> <p>Git LFS does this by replacing large files in your repository with tiny pointer files. During normal usage, you'll never see these pointer files as they are handled automatically by Git LFS:</p> <ol> <li>When you add a file to your repository, Git LFS replaces its contents with a pointer, and stores the file contents in a local Git LFS cache. </li> </ol> <p></p> <ol> <li>When you push new commits to the server, any Git LFS files referenced by the newly pushed commits are transferred from your local Git LFS cache to the remote Git LFS store tied to your Git repository. </li> </ol> <p></p> <p>When you checkout a commit that contains Git LFS pointers, they are replaced with files from your local Git LFS cache, or downloaded from the remote Git LFS store.</p> <p></p> <p>Git LFS is seamless: in your working copy you'll only see your actual file content. This means you can use Git LFS without changing your existing Git workflow; you simply git checkout, edit, git add, and git commit as normal. git clone and git pull operations will be significantly faster as you only download the versions of large files referenced by commits that you actually check out, rather than every version of the file that ever existed.</p> <ol> <li>Download git-lfs</li> <li>Check installation: <code>git lfs --version</code></li> <li>Initialize git-lfs once for your username: <code>git lfs install</code></li> </ol> <p>If you do a cat ~/.gitconfig, you should see the following added to your git configuration:</p> <pre><code>[filter \"lfs\"]\n    smudge = git-lfs smudge -- %f\n    process = git-lfs filter-process\n    required = true\n    clean = git-lfs clean -- %f\n</code></pre> <ol> <li>On your GitLab repo: got to Settings -&gt; General -&gt; Visibility, project features, permissions -&gt; Enable Git LFS</li> <li>check your <code>.gitattributes</code> file. For everything you want to use git-lfs, give it the git-lfs attribute, like so:</li> </ol> <pre><code># Graphics: \n    *.png      filter=lfs diff=lfs merge=lfs -text\n    *.jpg      filter=lfs diff=lfs merge=lfs -text\n    *.jpeg     filter=lfs diff=lfs merge=lfs -text\n</code></pre>"},{"location":"contribute/#the-end","title":"THE END","text":""},{"location":"contribute/#optionalreadingfurther-materials","title":"optional/reading/further materials","text":"<ul> <li>YouTube is full of Git/GitLab/GitHub videos for all kinds of levels and features!!! For example: Brainhack Git introduction or GitHub CI</li> <li>Git cheat sheet by gitlab or github</li> <li>Atlassian tutorials and cheat sheet</li> <li>Troubleshooting: Oh shit git or Dangit git (are the same, but the latter is without swearing)</li> <li>Git branching</li> <li>Git GUIs </li> <li>Advanced Git commands</li> <li>NOWA workshops</li> <li>really, just type anything you want to know about Git in YouTube and you'll find a tutorial for it. </li> </ul>"},{"location":"gitlab/","title":"GitLab","text":"<p>Objectives\ud83d\udccd</p> <ul> <li>What is GitLab</li> <li>local vs. remote repository</li> <li>push</li> <li>pull</li> <li>clone</li> <li>fetch</li> <li>merge</li> <li>Merge conflict between your local and remote repository</li> </ul> <p>As mentioned in the introduction, GitLab is a platform for collaborative code development. Everything we did so far in this Git course we did on our local machine and nobody has access to our project. Because collaboration is a major part in science, we need to be able to have a centralized workflow without needing to send all of our files back and forth with emails. This is very cumbersome and also no one ever knows what is the current version because between sending an email and actually getting feedback some time will pass. By putting your project on a centralized repository and giving your collaborators access to this repository, they will: </p> <ul> <li>always see the latest version of the project</li> <li>see the development stream of the project (aka commit history)</li> <li>they can retrieve the project and make changes and either commit them directly or ask you if you want to incorporate those changes (<code>merge request</code>)</li> <li>they can comment on it </li> <li>they can open a discussion (<code>issue</code>)</li> <li>and much more...you can even do project management on gitlab if you want to</li> </ul> <p>All we have to do is to set up a remote repository on gitlab and synchronize our local work with this remote repository. First we need some more vocabulary:</p> <p>More Git vocabulary</p> <ul> <li><code>git push</code>: synchronize your local repository with the remote repository by pushing changes in the local repository into the remote repository</li> <li><code>git pull</code>: synchronize your local repository with the remote repository by pulling changes from the remote repository into the local repository</li> <li><code>git clone</code>: this gives you an exact copy of a remote repository on your local computer</li> <li><code>git fetch</code>: fetching the latest version from the remote repository into your staging area</li> </ul> <p>Task 9</p> <ul> <li>go to GitLab and log in.</li> <li>click on \"new project\" \u2192 \"create a blank project\".</li> <li>give the project the name, preferrably the same name as your local folder has.</li> <li>under \"Project URL\" select your name.</li> <li>select \"public\" as visibility level.</li> <li>uncheck the box \"Initialize with a README\".</li> </ul> <p>We are now presented with this page:</p> <p></p> <p>This page basically presents you with different options on how to fill your gitlab repository. Because you already have a git repository, namely the Git project on your local machine, we need the last option \"Push an existing git repo\". </p> <p>Task 10</p> <p>Follow the instructions given by gitlab for \"Push an existing git repo\". After you did all of this, refresh the page. </p> I get an error when I push via ssh <p>First, please check that you followed the GitLab ssh instructions as linked on the setup page. If you did and it doesn't work, it's likely that the ssh connection to gitlab wasn't properly stored in your <code>.ssh config</code>. Here's how you can solve this:</p> <ul> <li>navigate in the terminal to your <code>.ssh</code> folder. It's in your root directory, so <code>cd ~/.ssh</code> should work for everyone</li> <li>inside this folder, check if you have <code>config</code> file by typing <code>ls</code> </li> <li>if you see a file named <code>config</code> in the list open it. If not, create this file. Both can be done by typing <code>nano config</code> (if you have nano as a text editor). Other ways can be <code>touch config</code> or <code>vi config</code>, whichever works for you</li> <li> <p>inside this file you have to write the following (watch the indentation!): </p> <p>Host gitlab.com HostName gitlab.com IdentityFile ~/.ssh/id_ed25519  # replace id_ed25519 with the name of your own ssh key</p> </li> <li> <p>save and close the file and try <code>git push --set-upstream origin --all</code> again </p> </li> </ul> <p>If that still doesn't work, you can also chose <code>HTTPS</code> instead of ssh. For this I recommend using a <code>Personal Access Token</code>. Because if you use https for push/pull/clone etc., you will always be asked for your <code>username</code> and <code>password</code>. However, if you use a personal access token, you only have to use it once and git will remember it. For creating a personal access token, follow these steps:</p> <ul> <li>click on your profile on the upper left and select <code>Preferences</code></li> <li>go to <code>Access Tokens</code> on the left sidebar</li> <li>click <code>add new token</code></li> <li>give it a name (e.g., the name of the machine you're currently using, like \"julia's macbook\"), delete the <code>expiration date</code>, and click <code>api</code> under <code>select scopes</code> </li> <li>click <code>create personal access token</code></li> <li>copy your token (THIS IS SUPER IMPORTANT! This is the only time you can actually see your token on gitlab, after that it will never be shown to you again, so please make sure to copy and save it somewhere you can find it again!)</li> <li>go to your terminal and type the following one after another:<ul> <li><code>git remote rename origin old-origin</code></li> <li><code>git remote add origin https-link-of-your-repo</code> \u2192 you can find the https link by going to your gitlab repo and clicking on the blue <code>code</code> button on the upper right and switch to <code>https</code></li> <li><code>git push --set-upstream origin --all</code></li> <li>now it will ask username and password. Give your <code>username</code> but instead of the password, put your access token!</li> </ul> </li> </ul> <p>Through the command <code>git push --set-upstream origin --all</code> we set up remote branches to track our local branches. The remote branches have the same names as our local branches but have a <code>origin/...</code> added. That's how git can distinguish local and remote work.</p> <p>Local vs. Remote Repository</p> <p>The local and the remote repository are two different things. You need to actively initiate the synchronization between the two (push-pull). </p> <p>One important thing to remember for understanding how the synchronization between git and GitLab works is:git makes you think you work on the same branches locally and remotely: they follow the same working stream and share the same version history, you don't need to switch between branches. But technically it\u2019s handled as if it\u2019s different branches: <code>main</code> vs. <code>origin/main</code>. This is necessary for the communication between local and remote repository to enable functions like <code>git merge</code> and <code>git diff</code>. </p> <p>Let's take a look at how the main page of a gitlab repository looks like:</p> <p></p> <ul> <li>at the top left we can see which branch of the project is currently displayed in the remote repository. When you click on it, you can change the branch and the files shown will automatically update according to the state of the files on this other branch</li> <li>on the top right you'll find the code for the repository which you (and others) will need to connect to the gitlab repo, for example for cloning the repository</li> <li>the marked part in the middle shows a commit message. Here it becomes evident why you should not just blindly add and commit everything at once. Because here you can see that your commits are bound to your files. If you always do <code>git add .</code> and commit, all your files will have the same commit message so the benefit of seeing at first sight what was last changed in this file is lost </li> <li>Lastly, you can see that README files in your repository will always be automatically rendered on the main page of the repo. This is another reason why you should have a nice and informative README file for your project</li> </ul>"},{"location":"gitlab/#gitlab-in-vscode","title":"GitLab in VSCode","text":"<p>If you work in VSCode, it automatically notices that you have a remote repository involved. When you click on the git graph on the left bar you can see the remote repository under <code>SOURCE CONTROL REPOSITORIES</code> and when you click on the arrow next to <code>commit</code> you can see that now you also have the option to <code>commit &amp; push</code> with one click. Tip: if you install the extension \"git graph\" you can also see your development stream in VSCode. </p>"},{"location":"gitlab/#working-collaboratively","title":"Working collaboratively","text":"<p>Because gitlab is the best to learn via working collaboratively, this is what we will do!</p> <p>Task 11</p> <ul> <li>Find a partner (find instructions on how to do this exercise alone below). Choose one of your gitlab repos to be the one you will both work on during the rest of this session.</li> <li>Add the person who is not the owner of the repository as a project member with the role \"Developer\"</li> </ul> <p>From now on the owner of the repository is called <code>owner</code> and the collaborator is called <code>developer</code>.</p> <ul> <li> <p><code>developer</code> clones the repository:</p> <ul> <li>navigate with the terminal to your desktop </li> <li>got to the <code>owners</code> gitlab repo by searching for their name. Click on the respective repo.</li> <li>click on the <code>code</code> button on the upper right</li> <li>copy the \"clone via ssh\"</li> <li>type in your terminal <code>git clone repo-link-you-just-copied</code></li> </ul> </li> <li> <p><code>developer</code> opens a file, makes a change, adds and commits it</p> </li> <li><code>developer</code> pushes the change to the repo by doing <code>git push repo-link-you-just-copied</code></li> <li><code>owner</code> refreshes gitlab repo to see if the change was updated</li> <li><code>owner</code> needs to incorporate the changes from the remote repo into the local repo: <code>git pull repo-ssh-link</code></li> <li><code>owner</code> opens a file, makes a change, adds and commits it</li> <li><code>owner</code>pushes the change to the repo by doing <code>git push</code></li> </ul> Instructions for doing this exercise alone <ul> <li>create a new folder on your desktop called <code>developer</code> and <code>cd</code> in it</li> <li>clone your own repository into the <code>developer</code> folder:<ul> <li>click on the <code>code</code> button on the upper right</li> <li>copy the \"clone via ssh\"</li> <li>type in your terminal <code>git clone repo-link-you-just-copied</code></li> </ul> </li> <li>follow the instructions above by switching between the original folder and the cloned repo in the <code>developer</code> folder (best is to open to separate VSCode windows to not get too confused)</li> </ul> <p>For the following tasks, <code>owner</code> refers to your \"original\" folder, and <code>developer</code> refers to the new folder that has the clone in it. So, you need to switch between those two folders regularly through changing directories in the terminal. </p> Project Member Roles and Permissions <p>The list is sorted from all to nothing, meaning the next lower level inherits the restrictions from the higher level.</p> <ul> <li>Owner: can do anything that is possible on the repository</li> <li>Maintainer: can't delete anything; can't assign, archive, transfer project or change visibility level</li> <li>Developer: + can't manage gitlab pages; can't change container registry and application security</li> <li>Reporter: + can't manage incidents</li> <li>Guest (This role applies to private and internal projects only.): + can't manage issues, merge requests; has almost no project management permissions</li> </ul> <p>git clone</p> <ul> <li>if you clone a repository it will only clone main </li> <li>to get the other branches of the remote repo:<ul> <li><code>git branch \u2013a</code>  shows you all available branches (e.g., origin/eyetrack)</li> <li><code>git checkout eyetrack</code>: creating a local Branch and git automatically detects that there is a remote sibling branch</li> <li>git output: branch \u2018Party2' set up to track 'origin/eyetrack\u2019</li> <li>repeat for every branch you want to have locally available</li> </ul> </li> </ul> <p>git pull</p> <p><code>git pull</code> means you are pulling the version from the remote origin branch directly into your working directory which also means an automatic merge of remote and local branch. It therefore updates your git repo AND your working directory in one command.</p> <p>git fetch</p> <ul> <li><code>git fetch</code> means that git is updating the remote branch in your local git repo called <code>origin/main</code> where it contains the latest remote version of the project. It is not updating your local branch <code>main</code>. </li> <li>that\u2019s why you have to (or can) merge: your corresponding local branch <code>main</code> in your working directory contains a different version of the project than the remote branch <code>origin/main</code></li> <li>that\u2019s also the reason why you can do git diff: it compares our <code>main</code> branch in the working directory with the <code>origin/main</code> branch in the git repo</li> <li><code>git fetch</code> is helpful if you want to inspect the changes from the remote repository first before incorporating them locally. Because maybe a merge conflict is hiding in the remote version </li> </ul>"},{"location":"gitlab/#summary-gitlab-workflow","title":"Summary gitlab workflow","text":"<p> <sup>1</sup></p>"},{"location":"gitlab/#merge-conflict-between-local-and-remote-repository","title":"Merge conflict between local and remote repository","text":"<p>Like mentioned previously, merge conflicts are not unusual and happen more often when you work collaboratively. It is very likely that your collaborator works on the project at the same time as you and sometimes those changes overlap. This is why we want to practice how to solve a merge conflict with the remote repository.</p> <p>Task 12</p> <ul> <li>work with your partner from the previous task again (when alone: your <code>developer</code> folder is your partner, still)</li> <li><code>developer</code> does a <code>git pull</code></li> <li><code>developer</code> and <code>owner</code> both make a change to the project at the same spot, e.g., modify the same line in the instructions</li> <li><code>developer</code> does a <code>git push</code> first</li> <li>then <code>owner</code> does a <code>git push</code></li> <li><code>owner</code> should get a message saying:</li> </ul> <p>rejected! error: failed to push some refs to 'repo url' hint: Updates were rejected because the remote contains work that you do not have locally. This is usually caused by another repository pushing to the same ref. You may want to first integrate the remote changes (e.g., 'git pull ...') before pushing again. </p> <p>This error message is not due to the merge conflict but due to the fact that <code>owner</code> made one more commit to the commit history and therefore expanded the commit history. As you both work on the same branch and git works in a linear way, git cannot put two commits at the same place but only one after another. Git expects you to have the latest version with all commits before you make another one. So, you will also receive this message when you don't have a merge conflict but simply didn't pull the latest version first.  </p> <p>Task 13</p> <ul> <li>work with your partner/ developer folder from the previous task again</li> <li><code>owner</code> does a <code>git pull</code></li> <li><code>owner</code> should get a merge conflict message like the one we saw before</li> <li><code>owner</code> needs to resolve merge conflict (we learned how to do that already, yeah!)</li> <li><code>owner</code> can now do a <code>git push</code></li> </ul> Tips for working collaboratively with git <ul> <li>make use of <code>branches</code>. Sometimes weird things happen when everyone is committing to the main branch all the time. Just create a branch for your own work and <code>merge</code> the updates from <code>main</code> into your branch regularly</li> <li>make use of <code>merge requests</code> (we will learn this in the next section). This way you can incorporate a second communication channel with your collaborators and give them a chance to not only inspect but also discuss the changes before merging them into the <code>main</code> branch</li> <li>before you start your work at the beginning of your day, do a <code>git fetch</code>, inspect the changes, and <code>merge</code> them</li> </ul> <ol> <li> <p>Image by Peer Herholz\u00a0\u21a9</p> </li> </ol>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#where-version-control-comes-from","title":"Where Version Control Comes from","text":"<p>Version Control originally comes from software development. Of course, we develop software, too, like our experiment or data analysis code. However, we often do not develop our code in a team with hundreds of people. When developing an app like a very simple gaming app, a lot of people are involved in active development at the same time. Also, a source code for a very simple gaming app has at least 50,000 rows of code. The code for analysing our research data likely has a lot less rows. The code for the gaming app also has different components (modules) and therefore the usual development process is divided in those modules, meaning that one person is responsible for one module. In the end, those modules have to come together smoothly. Also, apps usually come in different versions. We all heard about alpha-, beta-, or release-version of apps. </p> <p>So professional software developers were confronted with several challenges: </p> <ul> <li>Keep track of what each person is changing in the code</li> <li>incorporate changes without breaking another module</li> <li>have multiple streams of work for different versions</li> <li>etc.</li> </ul> <p>Sometimes Git might work in a way that is a bit too divided for your way of working (i.e., going in small-sized steps). There might be steps in the Git workflow that you consider unnecessary for your own needs. Then it always helps to remember where version control comes from to understand why the version control system is working in the way it does. </p> <p><p><p>via GIPHY</p></p></p>"},{"location":"introduction/#centralization","title":"Centralization","text":"<p>Another key challenge in software development is facilitating collaborative code development independent of time and space, i.e., centralization. With Git, you are only provided with local version control, meaning it is a software that runs on your computer and no one else has access to your work (=decentralized). For collaborative code development it is necessary that all developers have access to the same project and are able to see all of the projects changes and history (=centralized). </p> Collaborative code development dependent on time and space \u2192 Collaborative code development independent from time and space<sup>2</sup> <p>For this, collaborative coding platforms such as GitHub or GitLab are key. This is also a common misconception of Git: Git is NOT the same as GitHub/GitLab. They're independent of each other, in principle. You can use Git on your local without using GitHub/GitLab, and you can use GitHub/GitLab without using Git on your local machine. However, the combination of Git and GitHub/GitLab will give you the best of both worlds: Being able to track everything your doing on your local machine even if you don't have internet access as well as sharing everything you did with your collaborators with just one command. </p> <p><p><p>via GIPHY</p></p></p> Git GitHub/GitLab - git is a software on your computer - collaboration platforms based on the git software - decentralized - centralized - local version control - distributed version control"},{"location":"introduction/#benefits-of-version-control","title":"Benefits of Version Control","text":"<ul> <li>Traceability<ul> <li>Track changes</li> <li>Annotate each change with a message (=explain what and why) = a complete annotated history of the code</li> </ul> </li> <li>multiple streams of work (or version sets) independent from each other while also being able to merge the work back together</li> <li>For collaborative work this means:<ul> <li>keeps all team members on the same page </li> <li>makes sure that all team members can work simultaneously on the same project </li> <li>makes sure that everybody is working on the latest version of the project</li> </ul> </li> </ul>"},{"location":"introduction/#the-basic-principle-of-git","title":"The basic principle of Git","text":"<p>As a version control system, what Git does is simply store different version of your project for you. Git itself is a software that provides you with a server database in which the different versions of your project will be stored. All of these versions can be looked at and retrieved at any time, using the appropriate commands. So, what it is important for working with Git is to know how to communicate with it, i.e., knowing the language of Git (which we will learn during this course!). </p> The basic principle of Git. Local folder vs. git version database."},{"location":"introduction/#how-the-versioning-works","title":"How the versioning works","text":"<p>\"Ok, so how exactly does Git store different versions of my project?\" </p> <p>Well, every time you want to save the current state of your project (=one version), git takes a \"snapshot\" of how your folder currently looks like (=commit a version). The reference to this snapshot (=commit hash) will then be saved in your commit history and with this commit hash you can find this version in your version database aka git repository. Committing a version means saving a snapshot of how all your files currently look like. </p> <p>Hello git, please save the current state of the project</p> <ul> <li>making a commit = git's taking a snapshot of the current stage of your project and saving it in the git repository</li> <li>commits are stand alone versions of the project</li> <li>for every commit, git creates a hash which looks like this: 7c35a3ce607a14953f070f0f83b5d74c2296ef93</li> <li>all hashes can be found in the commit history and can be used to look at or retrieve an earlier version </li> </ul> <p>\"Where is this version database?\"</p> <p>When you ask Git to version control your files (=initialize Git), it will create a hidden folder inside your local folder. This hidden folder (called .git) is your version database. </p> After initializing Git in your project folder, a hidden .git folder is placed inside your project folder. Inside this hidden .git folder the different versions of the project are stored.  <p>\"What does \"different versions\" of my project even mean? How do I know when to commit a version and when not?\"</p> <p>First of all: The expression \"comitting a version\" actually should be \"comitting changes\". Because that's what you do: You start with a first version of your project and time after time you change things compared to previous versions. So, what you commit in the end are actually the changes to the project.</p> <p>Second: For the decision on when to make a commit, it is important to know that every time you make a commit you're being asked to write a short description of what this commit is about (=commit message). So, what you should ask yourself before making a commit is: \"Is the change between my current version compared to the previous version worth being saved as a stand alone version of my project?\". </p> <p>The commit message you give is bound to your commit, i.e., the commit message should state what you changed. Only then you will be able to figure out to which commit you need to go back if you're looking for a specific version of your project.</p> <p>Another practice about commits is to commit changes that belong together. Namely, if you changed something in file1 and something in file2 and those changes are logically related, you should commit them together. If changes you made are not logically related, you should commit them separately. </p> <p>Example for logically related changes</p> <p>You are working on a project where you have to conduct an experiment, analyse the data, and publish a manuscript. You make a change to your stimuli-coding-file by coding a new stimuli shape. You insert this new stimuli shape in your experiment code as well. The changes happened in different files, yet the changes are logically related (make new shape - use new shape). You should commit those changes together, meaning after you changed both files. </p> <p>Example for NOT logically related changes</p> <p>You are working on a project where you have to conduct an experiment, analyse the data, and publish a manuscript. You make a change to your stimuli-coding-file by coding a new stimuli shape. On the same day, you also make a change in our manuscript (which is awesome, btw), changing the affiliation of one of the co-authors. Those changes are not logically related. You should not put them in the same commit. </p>"},{"location":"introduction/#the-staging-area","title":"The staging area","text":"<p>\"But what if I worked on multiple different things since the last committed version and now I'm ready to commit my changes? Will I not have to commit all files together then?\"</p> <p>Luckily, no! Git has something called the staging area which solves this problem. Staging your files is basically giving your files a valid ticket for a ride to the version database. Only the files with a valid ticket for the next train (= the files you staged) can get onto the this train and take a ride to the version database (= commit to the version database). Every other file is left behind. </p> <p>In the end, the basic Git workflow looks like this:</p> Basic git workflow. Every change you want to commit needs to be staged first. Only staged changes will be committed in a new version.   <p>My staged changes being excited to take the train to version database:</p> <p><p><p>via GIPHY</p></p></p> <p>My staged changes showing commitment and getting on board:</p> <p><p><p>via GIPHY</p></p></p> <p>My unstaged changes watching the staged changes take off: </p> <p><p><p>via GIPHY</p></p></p> <p>My committed changes arriving at version database:</p> <p><p><p>via GIPHY</p></p></p> <ol> <li> <p>Text generated with ChatGPT.\u00a0\u21a9</p> </li> <li> <p>Figures retrieved from Freepik.\u00a0\u21a9</p> </li> </ol>"},{"location":"setup/","title":"Installation and Setup","text":""},{"location":"setup/#git-configuration","title":"Git configuration","text":"<p>First: Download Git. After installing Git, please run these commands one after another in your terminal (it doesn\u2019t matter in which directory you currently are) to check and complete your setup (you can just copy-paste the commands): <pre><code>git --version\n</code></pre> \u2192 this tells you if the installation was successful by telling you the version number of git you installed. <pre><code>git config --global user.name \"Example Name\"\n</code></pre> \u2192 put in your real name. You have to set the quotation marks around your name otherwise git can\u2019t read it. <pre><code>git config --global user.email example@example.com\n</code></pre> \u2192 choose your preferred email. <pre><code>git config --global init.defaultBranch main\n</code></pre> \u2192 this makes sure that your default branch is main, which is currently used by most users as their default branch. Don\u2019t worry about what it means, we will talk about that in the workshop \u263a <pre><code>git config --global core.editor ExampleEditor\n</code></pre> \u2192 this sets a default text editor when working with git. Just type in the editor you want to use. My recommendation is to use nano or vim. You don\u2019t have to download anything, it\u2019s already on your machine as it is a command-line editor. So, it\u2019s super convenient for working with git, as the git commands are also run in the command-line. It simply means that when writing commit messages you can do it in one window (i.e., your terminal) and you don't have to bother with a new window opening and making sure it's really closed etc. But of course, you can use any text editor you want. Just as an example, for making nano your gloab git-editor type <code>git config --global core.editor nano</code>. </p> <p><pre><code>git config --global pull.rebase false\n</code></pre> <pre><code>git config --global pull.merge true\n</code></pre> \u2192 this makes sure that your merges are shown in the commit history which is nice if you just start learning to use Git. When you're more experienced, git rebase is also a very nice command (we'll learn about that in the course!). <pre><code>cat ~/.gitconfig\n</code></pre> \u2192 checks if your configuration was successful. It should give you this output:</p> <pre><code>  [user] name = Your Name email = yourname@yourplace.org\n  [core] editor = YourEditor\n  [init] defaultBranch = main\n  [pull] rebase = false merge = true\n</code></pre>"},{"location":"setup/#gitlab-account","title":"GitLab account","text":"<ul> <li>For this course you must have an account on gitlab.com. This is a different GitLab from our University GitLab which we provide through the DataHub. As our instructors Peer and Michael are not part of University Marburg, they don't have access to our University GitLab. Hence, we set up this course on gitlab.com to ensure access to EVERYONE. </li> <li>Please set up an ssh connection to communicate with GitLab. You can follow these instructions to do so.</li> <li>The very important part is to check if you can connect by typing <code>ssh -T git@gitlab.com</code> in your terminal. It should give you this </li> </ul> <pre><code>The authenticity of host 'gitlab.com (35.231.145.151)' can't be established.\nECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw.\nAre you sure you want to continue connecting (yes/no)? yes\n</code></pre> <p>YES!</p> <pre><code>Warning: Permanently added 'gitlab.com' (ECDSA) to the list of known hosts.\n</code></pre>"},{"location":"setup/#vscode","title":"VSCode","text":"<p>I always recommend to work in VSCode for various reasons. With Git it is even more convenient, as it has a built-in terminal and a built-in Git integration. What is more, you can install multiple extension packs for Git as well as for GitLab. </p> <p>When you open VSCode you see a \"brick\" symbol on the left side bar. This is for installing extensions. I recommend installing the Git Graph extension and the GitLab Workflow extension. </p> <p>You can of course use any editor you want, though. This is just a recommendation. </p>"}]}